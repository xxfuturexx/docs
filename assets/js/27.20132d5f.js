(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{415:function(t,e,a){"use strict";a.r(e);var s=a(54),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"vue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[t._v("#")]),t._v(" Vue")]),t._v(" "),a("h3",{attrs:{id:"面试题-vue2-x-生命周期有哪些-⭐⭐⭐"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题-vue2-x-生命周期有哪些-⭐⭐⭐"}},[t._v("#")]),t._v(" 面试题：Vue2.x 生命周期有哪些？⭐⭐⭐")]),t._v(" "),a("p",[t._v("1.系统自带八个")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  beforeCreate() {}, //生命周期 - 创建之前\n  created() {},  //生命周期 - 创建完成（可以访问当前this实例，可调用methods中的方法，访问和修改data数据触发响应式渲染dom，可通过computed和watch完成数据计算）\n  \n  beforeMount() {}, //生命周期 - 挂载之前\n  mounted() {},  //生命周期 - 挂载完成（可以访问DOM元素）\n  \n  beforeUpdate() {}, //生命周期 - 更新之前\n  updated() {}, //生命周期 - 更新之后\n  \n  beforeDestroy() {}, //生命周期 - 销毁之前\n  destroyed() {}, //生命周期 - 销毁完成\n  \n特殊场景的生命周期：  \nactivated\t\tkeep-alive 缓存的组件激活时触发\ndeactivated\t\tkeep-alive 缓存的组件停用时调用\nerrorCaptured\t捕获一个来自子孙组件的错误时被调用\nCaptured(e:捕获)\n")])])]),a("p",[t._v("2.当一旦进入到某个组件会执行哪些生命周期")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" beforeCreate() {}, //生命周期 - 创建之前\n created() {},  //生命周期 - 创建完成（可以访问当前this实例）\n beforeMount() {}, //生命周期 - 挂载之前\n mounted() {},  //生命周期 - 挂载完成（可以访问DOM元素）\n")])])]),a("p",[t._v("3.$el和$data在哪个阶段有")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" beforeCreate() {},  啥也没有\n created() {},       有$data没有$el\n beforeMount() {},   有$data没有$el\n mounted() {},  \t\t 有$data有$el\n \n $data就是数据 data \n $el就是节点，本组件的根节点\n")])])]),a("p",[t._v("4.如果使用keep-alive会多俩个生命周期")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("activated() {}, //如果页面有keep-alive缓存的组件激活时，这个函数会触发\ndeactivated() {}, //keep-alive 缓存的组件停用时调用\n")])])]),a("p",[t._v("5.如果加入keep-alive第一次进入组件会执行哪些生命周期")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("beforeCreate \ncreated \nbeforeMount \nmounted \nactivated\n")])])]),a("p",[t._v("6.如果加入keep-alive第二次或者第N进入该组件会执行哪些生命周期")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("activated\n")])])]),a("h3",{attrs:{id:"面试题-谈谈你对keep-alive的了解⭐"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题-谈谈你对keep-alive的了解⭐"}},[t._v("#")]),t._v(" 面试题：谈谈你对keep-alive的了解⭐")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("keep-alive ： 这是vue内置的一个组件，功能是来缓存组件的。\n一旦使用了keep-alive会多俩个生命周期：\n\t\tactivated() {}, //keep-alive 缓存的组件激活时触发\n\t\tdeactivated() {}, //keep-alive 缓存的组件停用时调用\n")])])]),a("h3",{attrs:{id:"面试题-v-if和v-show区别⭐⭐⭐"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题-v-if和v-show区别⭐⭐⭐"}},[t._v("#")]),t._v(" 面试题：v-if和v-show区别⭐⭐⭐")]),t._v(" "),a("blockquote",[a("p",[t._v("共同点：都是控制标签的隐藏和显示")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("一、创建和显示\n\tv-if \t\t创建和删除的操作,v-if直接从dom树删除      ===》重绘\n\tv-show \t\t用的display:none隐藏（频繁切换时使用）    ===》会造成回流和重绘\n\n")])])]),a("p",[t._v("二、性能")]),t._v(" "),a("ul",[a("li",[a("p",[a("code",[t._v("v-show")]),t._v(" 由"),a("code",[t._v("false")]),t._v("变为"),a("code",[t._v("true")]),t._v("的时候不会触发组件的生命周期")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("v-if")]),t._v("由"),a("code",[t._v("false")]),t._v("变为"),a("code",[t._v("true")]),t._v("的时候，触发组件的"),a("code",[t._v("beforeCreate")]),t._v("、"),a("code",[t._v("create")]),t._v("、"),a("code",[t._v("beforeMount")]),t._v("、"),a("code",[t._v("mounted")]),t._v("钩子，由"),a("code",[t._v("true")]),t._v("变为"),a("code",[t._v("false")]),t._v("的时候触发组件的"),a("code",[t._v("beforeDestory")]),t._v("、"),a("code",[t._v("destoryed")]),t._v("方法")])])]),t._v(" "),a("p",[t._v("性能消耗：所以"),a("code",[t._v("v-if")]),t._v("有更高的切换消耗；"),a("code",[t._v("v-show")]),t._v("有更高的初始渲染消耗；")]),t._v(" "),a("blockquote",[a("p",[t._v("重绘与回流(重排)的概念")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("回流(重排): 当浏览器必须重新处理和绘制部分或全部页面时，回流就会发生\n\n重绘: 不影响布局, 只是标签页面发生变化, 重新绘制\n\n注意: 回流(重排)必引发重绘, 重绘不一定引发回流(重排)\n")])])]),a("h3",{attrs:{id:"面试题-v-if和v-for优先级-2-x"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题-v-if和v-for优先级-2-x"}},[t._v("#")]),t._v(" 面试题：v-if和v-for优先级 2.x")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("v-for 比 v-if高\n")])])]),a("h3",{attrs:{id:"面试题-ref是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题-ref是什么"}},[t._v("#")]),t._v(" 面试题：ref是什么？")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("通过id / ref, 都可以获取原生DOM节点\n$refs-可以获取组件对象\n")])])]),a("h3",{attrs:{id:"面试题-nexttick是什么-⭐⭐"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题-nexttick是什么-⭐⭐"}},[t._v("#")]),t._v(" 面试题：nextTick是什么？⭐⭐")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("nextTick是Vue提供的一个全局API,是在下次DOM更新循环结束之后执行延迟回调，在修改数据之后使用$nextTick，则可以在回调中获取更新后的DOM\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("因为DOM更新是异步的，获取不到要用$nextTick()\n等dom都加载完毕，才会执行$nextTick()里的代码\n")])])]),a("p",[t._v("​\t\t\t\t面试题：Vue中如何做样式穿透")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(">>>     【stylus】\n/deep/  【sass、less】\n::v-deep 【通用】\n")])])]),a("h3",{attrs:{id:"面试题-scoped原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题-scoped原理"}},[t._v("#")]),t._v(" 面试题：scoped原理")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("当组件的style使用了scoped，该组件中的所有dom节点会加入自定义属性data-v-xxx，css会匹配到h1[data-v-xxx]从而实现css局部化\n说白了：就是css属性选择器\n")])])]),a("h3",{attrs:{id:"面试题-vuex是单向数据流还是双向数据流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题-vuex是单向数据流还是双向数据流"}},[t._v("#")]),t._v(" 面试题：Vuex是单向数据流还是双向数据流？")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("单向数据流\n")])])]),a("h3",{attrs:{id:"面试题-讲一下mvvm⭐⭐⭐"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题-讲一下mvvm⭐⭐⭐"}},[t._v("#")]),t._v(" 面试题：讲一下MVVM⭐⭐⭐")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型层，负责处理业务逻辑以及和服务器端进行交互，View代表视图层，负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。\n")])])]),a("h3",{attrs:{id:"面试题-双向绑定原理-忘-⭐⭐⭐0"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题-双向绑定原理-忘-⭐⭐⭐0"}},[t._v("#")]),t._v(" 面试题：双向绑定原理（忘）⭐⭐⭐0")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\t当一个Vue实例创建时，Vue会遍历data选项的属性，用 Object.defineProperty 将它们转为 getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher重新计算，从而致使它关联的组件得以更新。\n")])])]),a("img",{attrs:{src:"/assets/interview-img/双向数据绑定.jpg"}}),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1. 初始化的时候，把所有视图层的数据添加到对象中\n2. 劫持数据发生的改变【哪个数据添加了v-model】\n3. 劫持的数据去会通知dep（订阅者）：dep知道哪个数据要改变\n4. dep订阅者通知waterch对象，触发update方法来更新视图层\n\n补充：\ndata是响应式的，因为data的数据要赋值给new Vue这个实例，而且this.xxx改变data也会跟着改变，所以data是响应式的\n")])])]),a("h3",{attrs:{id:"面试题-什么是虚拟dom⭐⭐⭐0"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题-什么是虚拟dom⭐⭐⭐0"}},[t._v("#")]),t._v(" 面试题：什么是虚拟DOM⭐⭐⭐0")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1. 虚拟DOM是什么?\n   本质就是一个JS对象, 保存DOM关键信息\n2. 虚拟DOM好处?\n    提高DOM更新的性能, 不频繁操作真实DOM, 在内存中找到变化部分, 再更新真实DOM(打补丁)\n")])])]),a("h3",{attrs:{id:"面试题-key是干什么-⭐⭐⭐"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题-key是干什么-⭐⭐⭐"}},[t._v("#")]),t._v(" 面试题：key是干什么？⭐⭐⭐")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("key：是dom的唯一标识，key是可以配合虚拟dom提高更新的性能(如果节点的key不同，那么就会新建)。\n")])])]),a("h3",{attrs:{id:"面试题-diff算法⭐⭐⭐"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题-diff算法⭐⭐⭐"}},[t._v("#")]),t._v(" 面试题：diff算法⭐⭐⭐")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("vue用diff算法, 让新虚拟dom和旧的虚拟dom进行比较\n1.同级比较\n2.根元素变化时，删除，重新建立整个dom树\n3.根元素没变, 属性改变, 元素复用, 更新属性\n4.根元素没变, 子元素没变, 元素内容改变\n\t无key - 就地更新\n\t有key，按照key值进行比较\n\t\n\t有key - 值为id时\n\t新DOM里数据的key存在, 去旧的虚拟DOM结构里找到key标记的标签, 复用标签\n\n\t新DOM里数据的key存在, 去旧的虚拟DOM结构里没有找到key标记的标签, 创建\n\n\t旧DOM结构的key, 在新的DOM结构里没有了, 则移除key所在的标签\n")])])]),a("p",[t._v("​\t\t\t\t面试题：Vue组件传值")]),t._v(" "),a("h3",{attrs:{id:"面试题-props和data优先级谁高-谁先执行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题-props和data优先级谁高-谁先执行"}},[t._v("#")]),t._v(" 面试题：props和data优先级谁高（谁先执行）？")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Props ->  Methods ->  Data -> Computed -> Watch \n")])])]),a("h3",{attrs:{id:"面试题-computed、methods、watch有什么区别-⭐⭐"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题-computed、methods、watch有什么区别-⭐⭐"}},[t._v("#")]),t._v(" 面试题：computed、methods、watch有什么区别？⭐⭐")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" computed 计算属性\n watch\t 可以侦听data/computed属性值改变\n \n1. computed有缓存，methods没缓存，watch[只要数据不变，就不会执行]\n2. 一旦进入组件会执行 computed、methods\n3. watch可以监听数据发生的改变（新老值），路由发生改变（新老路由）\n\n***注意能扩展一下优先级是最好的了！\n")])])]),a("h3",{attrs:{id:"面试题-vue的优势-好处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题-vue的优势-好处"}},[t._v("#")]),t._v(" 面试题：Vue的优势（好处）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\t简单易学, 轻量级整个源码js文件不大, 双向数据绑定, 数据驱动视图, 组件化, 数据和视图分离, \n\n​\tvue负责关联视图和数据, 作者中国人(尤雨溪), 文档都是中文的, 入门教程非常多, 上手简单. \n\n​\t相比传统网页, vue是单页面可以只刷新某一部分\n")])])]),a("h3",{attrs:{id:"面试题-vuex⭐⭐⭐0"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题-vuex⭐⭐⭐0"}},[t._v("#")]),t._v(" 面试题：Vuex⭐⭐⭐0")]),t._v(" "),a("p",[t._v("Vuex是采用集中式管理组件依赖的共享数据的一个工具，可以解决不同组件数据共享问题。")]),t._v(" "),a("img",{staticStyle:{zoom:"67%"},attrs:{src:"/assets/interview-img/Vuex.png"}}),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("getters:{\n\t放置所有的vuex的计算属性\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1. vuex有哪些属性：state、mutations、actions、getters、modules\n2. 为什么在组件中不能直接修改state或getters中的数据：因为vuex是单向数据流\n\t怎么改：通过mutations去修改\n3. mutations 和 actions 区别\n\tmutations必须是同步函数、actions可以包含异步操作\t\n4. 使用\n\tactions是来提交mutations，尽量别直接在actions中写入方法\n\tmutations是来改变state数据的。\n\t如果是异步就放在actions中、同步放在mutations中\n\n***注意：vuex 本身不能做持久化存储（刷新页面数据回到原点）。\n解决：用localStorage或者vuex-persist插件。\n")])])]),a("h3",{attrs:{id:"面试题-vue路由"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题-vue路由"}},[t._v("#")]),t._v(" 面试题：Vue路由")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1. Vue路由模式：history、hash\n\t\thistory url不带#,hash样式是url带#\n\t\t前端测试打包后组件内容空白，需要从history改成hash模式，当然如果正常上线，可能用history但是需要后端设置重定向来解决组件模块不显示的问题。\n2. Vue路由导航守卫\n\t2.1 全局\n\t\tbeforeEach()\n\t\tbeforeResolve()\n\t\tafterEach()\n\t2.4 路由独享\t\n\t\t\tbeforeEnter()\n\t2.3 组件内\n\t\tbeforeRouteEnter()\n  \t\tbeforeRouteUpdate()\n \t \tbeforeRouteLeave()\n3. 动态路由\n\t 场景：详情页(新闻、商品)\n4. 路由传值\n\tthis.$router.push({\n\t\tquery:{a:1}\n\t})\n\t\n\tthis.$router.push({\n\t\tparams:{b:2}\n\t})\n")])])]),a("h3",{attrs:{id:"面试题-vue项目打包后出现空白页"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试题-vue项目打包后出现空白页"}},[t._v("#")]),t._v(" 面试题：Vue项目打包后出现空白页")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1. vue.config.js没有加入\n\tmodule.exports = {\n \t \tpublicPath:'./'\n\t}\n2. 前端测试的时候：有路由没有页面数据。\n\t测试环节路由需要改成：hash模式\n\t上线用history，但是后端要做重定向\n")])])]),a("h3",{attrs:{id:"_01、单页应用-⭐⭐⭐"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_01、单页应用-⭐⭐⭐"}},[t._v("#")]),t._v(" 01、单页应用 ⭐⭐⭐")]),t._v(" "),a("blockquote",[a("p",[t._v("https://vue3js.cn/interview/vue/spa.html#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFspa")]),t._v(" "),a("p",[a("em",[t._v("单页")]),t._v("Web"),a("em",[t._v("应用")]),t._v("（single page web application，SPA），就是只有一张Web页面的"),a("em",[t._v("应用")]),t._v("，是加载单个HTML 页面并在用户与"),a("em",[t._v("应用")]),t._v("程序交互时动态更新该页面的Web"),a("em",[t._v("应用")]),t._v("程序。")]),t._v(" "),a("h4",{attrs:{id:"单页应用优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单页应用优缺点"}},[t._v("#")]),t._v(" 单页应用优缺点")])]),t._v(" "),a("p",[t._v("优点：")]),t._v(" "),a("ul",[a("li",[t._v("具有桌面应用的即时性、网站的可移植性和可访问性")]),t._v(" "),a("li",[t._v("用户体验好、快，内容的改变不需要重新加载整个页面")]),t._v(" "),a("li",[t._v("良好的前后端分离，分工更明确")])]),t._v(" "),a("p",[t._v("缺点：")]),t._v(" "),a("ul",[a("li",[t._v("不利于搜索引擎的抓取")]),t._v(" "),a("li",[t._v("首次渲染速度相对较慢")])]),t._v(" "),a("h3",{attrs:{id:"_04-data为什么是函数⭐⭐"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_04-data为什么是函数⭐⭐"}},[t._v("#")]),t._v(" 04_data为什么是函数⭐⭐")]),t._v(" "),a("blockquote",[a("p",[t._v("https://juejin.cn/post/6844904185352159239")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\t每次实例化组件调用data函数，都会return一个新的对象，它们的内存地址都是不一样的，这样就不会相互影响使其组件拥有独立的对象数据。如果data不是函数，会共用一个对象，不具有独立性\n")])])])]),t._v(" "),a("h3",{attrs:{id:"_05、v-model原理-⭐⭐⭐0"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_05、v-model原理-⭐⭐⭐0"}},[t._v("#")]),t._v(" 05、v-model原理 ⭐⭐⭐0")]),t._v(" "),a("p",[t._v("https://juejin.cn/post/6844904015516401678")]),t._v(" "),a("p",[a("strong",[t._v("5.1_v-model原理解析")])]),t._v(" "),a("ul",[a("li",[t._v("v-model可以绑定一个动态值到视图，同时视图中变化能改变该值，"),a("code",[t._v("v-model")]),t._v("是语法糖("),a("code",[t._v("代码更简洁流畅，代码语义更自然...")]),t._v(")，默认情况下相当于:"),a("code",[t._v("value和@input")]),t._v("。")])]),t._v(" "),a("p",[a("strong",[t._v("5.2_实现原理")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("1、v-bind绑定 value 值")])]),t._v(" "),a("li",[a("p",[t._v("2、触发input事件并传递数据")])])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("（双向数据绑定）底层原理：v-model原理其实就是给input事件绑定oninput事件 就会立刻调用底层对象对应的setter方法 改变data里的属性的值 从而实现双向数据绑定\n")])])]),a("p",[a("strong",[t._v("通常在表单项上使用"),a("code",[t._v("v-model")])])]),t._v(" "),a("img",{attrs:{src:"/assets/interview-img/双向数据绑定.jpg"}}),t._v(" "),a("h3",{attrs:{id:"_09-父子组件生命周期顺序-⭐⭐"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_09-父子组件生命周期顺序-⭐⭐"}},[t._v("#")]),t._v(" 09_父子组件生命周期顺序 ⭐⭐")]),t._v(" "),a("blockquote",[a("p",[t._v("https://segmentfault.com/a/1190000015890245")]),t._v(" "),a("p",[t._v("https://www.cnblogs.com/ming1025/p/13083570.html")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("加载渲染过程\n父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted\n父组件先创建，然后子组件创建；子组件先挂载，然后父组件挂载。\n\n子组件更新过程\n父beforeUpdate->子beforeUpdate->子updated->父updated\n\n父组件更新过程\n父beforeUpdate->父updated\n\n销毁过程\n父beforeDestroy->子beforeDestroy->子destroyed->父destroyed\n")])])]),a("h3",{attrs:{id:"_10、vue组件间通信的方式-⭐⭐⭐0"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10、vue组件间通信的方式-⭐⭐⭐0"}},[t._v("#")]),t._v(" 10、Vue组件间通信的方式 ⭐⭐⭐0")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("一、从一个vue组件里把值传给另一个vue组件(父->子)\n从父到子的数据流向, 叫单向数据流\n父传子口诀(步骤)是什么?\n1. 父组件内, 使用属性方式给props变量传值\n2. 子组件内, props定义变量, 在子组件内使用变量\n\n\n二、子传父如何实现?(子 => 父)\n1. 子组件内, 恰当时机this.$emit('自定义事件名', 值)\n2. 父组件内, 给组件@自定义事件=\"父组件methods函数\"\n\n三、 跨组件传值（使用eventBus技术）\n1.创建空白Vue对象并导出\n2.在要传递值的组件使用 eventBus.$emit('事件名',值)\n3.要接受值的组件使用 eventBus.$on('事件名',函数体)\n")])])]),a("h3",{attrs:{id:"_11、vue单向数据流-⭐0"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11、vue单向数据流-⭐0"}},[t._v("#")]),t._v(" 11、Vue单向数据流 ⭐0")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Vue 的单向数据流：指数据一般从父组件传到子组件，子组件没有权利直接修改父组件传来的数据，即子组件从 props 中直接获取的数据，只能请求父组件修改数据再传给子组件。\n")])])]),a("h3",{attrs:{id:"_13、slot插槽-⭐"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13、slot插槽-⭐"}},[t._v("#")]),t._v(" 13、slot插槽 ⭐")]),t._v(" "),a("blockquote",[a("p",[t._v("https://vue3js.cn/interview/vue/slot.html")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Slot 艺名插槽，花名“占坑”，我们可以理解为solt在组件模板中占好了位置，当使用该组件标签时候，组件标签里面的内容就会自动填坑（替换组件模板中slot位置），作为承载分发内容的出口\n\n1.默认插槽\n子组件用<slot>标签来确定渲染的位置\n父组件在使用的时候，直接在子组件的标签内写入内容即可\n\n2.具名插槽\n子组件用name属性来表示插槽的名字\n父组件中在使用时在默认插槽的基础上加上v-slot(可以简写成#)属性，值为子组件插槽name属性值\n\n3.作用域插槽\n子组件在作用域上绑定属性来将子组件的信息传给父组件使用，这些属性会被挂在父组件v-slot接受的对象上\n父组件中在使用时通过v-slot:（简写：#）获取子组件的信息，在内容中使用\n")])])]),a("h3",{attrs:{id:"_18-vuex⭐⭐⭐"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_18-vuex⭐⭐⭐"}},[t._v("#")]),t._v(" 18_Vuex⭐⭐⭐")]),t._v(" "),a("h3",{attrs:{id:"_19-vue-router的两种模式⭐⭐"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_19-vue-router的两种模式⭐⭐"}},[t._v("#")]),t._v(" 19_vue-router的两种模式⭐⭐")]),t._v(" "),a("blockquote",[a("blockquote",[a("p",[t._v("https://juejin.cn/post/6844903552519766029")])])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1. Vue路由模式：history、hash\n\n\thistory url不带#,hash样式url带#\n\t\n   前端测试打包后组件内容空白，需要从history改成hash模式，当然如果正常上线，可能用history但是需要后端设置重定向来解决组件模块不显示的问题。\n")])])]),a("p",[t._v("第五章 面试题性能优化篇")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("性能优化最终目的：提升用户体验\n项目优化阶段：\n\t开发阶段\n\t生产阶段：不断优化的过程\n\t\t借助工具测试\n\t\tnpm install -g lighthouse\n\t\tlighthouse https://www.xuexiluxian.cn/\n\t\n1. 首次加载如何提升性能：\n\t1.1 减少http请求  \n\t\t解决：合并数据\n\t1.2 script标签加入顺序\n\t\t解决：<script\tdefer> 或者 放在/body前面\n\t1.3 多个小图标使用雪碧图\n\t1.4 懒加载\n\t1.5 减少重绘和回流\n\n2. 后端给你数据有10万条，你如何优化\n\t解决：长列表 （底部加载更多）\n\n3. 项目上线前的性能优化\n\t压缩打包html、css、js、图片（base64）等等\n")])])]),a("p",[t._v("第六章 面试题兼容篇")]),t._v(" "),a("p",[t._v("​\t\t6.1 页面样式兼容 【移动端】")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1. click事件在移动端有300ms延迟\n\t解决：<meta content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\" name=\"viewport\">     \n2. touch事件有穿透的问题\n\t解决：引入faskclick.js\n\tif ('addEventListener' in document) {\n    document.addEventListener('DOMContentLoaded', function() {\n      FastClick.attach(document.body);\n    }, false);\n  }\n3. IOS键盘首字母自动大写\n\t解决：<input type=\"text\" autocapitalize='off'> \n4. 在移动端修改难看的点击的高亮效果，iOS和安卓下都有效：\n\t解决：a,button,input{-webkit-tap-highlight-color:rgba(0,0,0,0);}\n5. 在IOS中new date日期对象 new Date('2021-1-1')不显示\n\t解决：var date = new Date('2021/1/1');\n")])])]),a("p",[t._v("​\t\t6.2 框架兼容")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("uni-app 获取可视区域高\nuni-app swiper固定高度\n")])])]),a("p",[t._v("第七章 面试题网络请求篇")]),t._v(" "),a("p",[t._v("​\t\t7.1 跨域面试题")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1. vue中可以设置代理，来解决跨域.\n\t问题：但是打包以后，代理就失效了。\n\t解决：可以配置\n\t\t\t\t.env.development(开发环境)\n\t\t\t\t.env.production（生产环境）\n2. 后端设置跨域(cors)\n3. jsonp\n")])])]),a("p",[t._v("​\t\t7.2 http和https")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("正常一个网页是http，可以配置成https，而https就是一个证书（就是一个文件）。\n\n1. https比http 更安全\n2. 口端不同http:80 、https:443\n")])])])])}),[],!1,null,null,null);e.default=n.exports}}]);