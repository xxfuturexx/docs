(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{402:function(t,a,s){"use strict";s.r(a);var e=s(54),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"css权重叠加盒子模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css权重叠加盒子模型"}},[t._v("#")]),t._v(" css权重叠加盒子模型")]),t._v(" "),s("h2",{attrs:{id:"优先级-权重"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优先级-权重"}},[t._v("#")]),t._v(" 优先级（权重）")]),t._v(" "),s("blockquote",[s("p",[t._v("不同的选择器之间会有不同的优先级")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("继承 < 通配符 < 标签选择器 < 类选择器 < ID选择器 < 行内样式 <　!important\n")])])]),s("p",[t._v("思考：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('<style>\n#test1 {\n\tcolor: red;\n}\n#test .son {\n\tcolor: green;\n}\n</style>\n<div class="box" id="test">\n\t<div class="son" id="test1">试问我这段文字的颜色</div>\n</div>\n')])])]),s("h2",{attrs:{id:"权重叠加"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#权重叠加"}},[t._v("#")]),t._v(" 权重叠加")]),t._v(" "),s("h3",{attrs:{id:"css特殊性-specificity"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css特殊性-specificity"}},[t._v("#")]),t._v(" CSS特殊性（Specificity）")]),t._v(" "),s("p",[t._v("关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity，我们称为CSS 特性或称非凡性，它是一个衡量CSS值优先级的一个标准 具体规范入如下：")]),t._v(" "),s("p",[t._v("specificity用一个四位的数 字串(CSS2是三位)来表示，更像四个级别，值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("继承或者* 的贡献值")]),t._v(" "),s("th",[t._v("0,0,0,0")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("每个元素（标签）贡献值为")]),t._v(" "),s("td",[t._v("0,0,0,1")])]),t._v(" "),s("tr",[s("td",[t._v("每个类，伪类贡献值为")]),t._v(" "),s("td",[t._v("0,0,1,0")])]),t._v(" "),s("tr",[s("td",[t._v("每个ID贡献值为")]),t._v(" "),s("td",[t._v("0,1,0,0")])]),t._v(" "),s("tr",[s("td",[t._v("每个行内样式贡献值")]),t._v(" "),s("td",[t._v("1,0,0,0")])]),t._v(" "),s("tr",[s("td",[t._v("每个!important贡献值")]),t._v(" "),s("td",[t._v("正无穷")])])])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("权重是可以叠加的\n\n比如的例子：\n\ndiv ul  li   ------\x3e      0,0,0,3\n.nav ul li   ------\x3e      0,0,1,2\na:hover      -----—>      0,0,1,1\n.nav a       ------\x3e      0,0,1,1   \n#nav p       ------\x3e      0,1,0,1\n")])])]),s("h2",{attrs:{id:"盒子模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#盒子模型"}},[t._v("#")]),t._v(" 盒子模型")]),t._v(" "),s("blockquote",[s("p",[t._v("网页的布局本质就是把网页上的元素，如图片，文字，都放入盒子里面，然后按照自己的需要摆放盒子的过程就是网页布局")])]),t._v(" "),s("p",[s("img",{attrs:{src:"/assets/css-img/t1.png",alt:"小米网页"}})]),t._v(" "),s("h3",{attrs:{id:"盒子模型的组成"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#盒子模型的组成"}},[t._v("#")]),t._v(" 盒子模型的组成")]),t._v(" "),s("p",[s("img",{attrs:{src:"/assets/css-img/20171105195348.jpg",alt:"盒子模型"}})]),t._v(" "),s("ol",[s("li",[t._v("width（电脑） + padding（海绵） + border（白色盒子框）")]),t._v(" "),s("li",[t._v("一张图诠释网页中的盒子模型完整的构成")]),t._v(" "),s("li",[t._v("而margin控制的是盒子与盒子之间的上下左右距离")])]),t._v(" "),s("h3",{attrs:{id:"边框"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#边框"}},[t._v("#")]),t._v(" 边框")]),t._v(" "),s("blockquote",[s("p",[t._v("边框有三部分组成：")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("border: 边框大小  边框样式（dashed 虚线 dotted 点线 double 双实线） 边框颜色;\n")])])]),s("blockquote",[s("p",[t._v("直接这么写边框控制的是上下左右四条边框，如果想要单独某一条边框的写法")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("border-方位名词:边框大小 边框样式 边框颜色;\n")])])]),s("blockquote",[s("p",[t._v("边框是一个复合属性，每一个部分都可以有单独的属性去控制 用的较少")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("边框大小；border-width\n边框样式：border-style\n边框颜色：border-color\n")])])]),s("ul",[s("li",[t._v("补充：细线表格 border-collapse:collapse;")]),t._v(" "),s("li",[t._v("圆角：borde-radius:值; 一个值控制的上左 上右 下右 下左;\n课外链接补充：\nhttp://www.ruanyifeng.com/blog/2010/12/detailed_explanation_of_css3_rounded_corners.html")])]),t._v(" "),s("h3",{attrs:{id:"内边距"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内边距"}},[t._v("#")]),t._v(" 内边距")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("padding的取值可以是1-4个\n\n一个值：控制整个上下左右\n两个值：第一个控制上下  第二个控制左右\n三个值：第一个控制的上 第二个控制的左右 第三个控制的下\n四个值：上右下左\n")])])]),s("p",[t._v("也可以单独写：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("padding-top\npadding-bottom\npadding-left\npadding-right\n")])])]),s("p",[s("strong",[t._v("注意")]),t._v("：行内元素里面不要写上下padding，左右可以")]),t._v(" "),s("p",[t._v("案例：新浪导航")]),t._v(" "),s("h3",{attrs:{id:"外边距"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#外边距"}},[t._v("#")]),t._v(" 外边距")]),t._v(" "),s("ol",[s("li",[t._v("margin的取值方式和padding一样")]),t._v(" "),s("li",[t._v("margin的大小只会移动盒子的位置，并不会对盒子的大小造成影响（特殊情况例外）")]),t._v(" "),s("li",[t._v("行内元素也不要给上下的margin")]),t._v(" "),s("li",[t._v("特殊值：auto  margin:0 auto; 可以让一个块级元素水平居中\n"),s("ul",[s("li",[t._v("前提条件：必须是块级元素 同时必须有固定的width")]),t._v(" "),s("li",[t._v("注意：text-align和margin:0 auto的不同 前者是控制盒子内部的文字或者内部的行内块  后者控制的是盒子本身")])])])]),t._v(" "),s("h4",{attrs:{id:"清除内外边距"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#清除内外边距"}},[t._v("#")]),t._v(" 清除内外边距")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("* { \n\tpadding: 0;\n\tmargin: 0; \n}\n")])])]),s("h4",{attrs:{id:"外边距的bug"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#外边距的bug"}},[t._v("#")]),t._v(" 外边距的BUG")]),t._v(" "),s("blockquote",[s("p",[t._v("相邻块元素垂直外边距的合并")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom，\n下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和\n而是两者中的较大者。这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。\n")])])]),s("p",[s("img",{attrs:{src:"/assets/css-img/www.png",alt:"相邻元素合并"}})]),t._v(" "),s("p",[t._v("解决方案：  避免就好了。")]),t._v(" "),s("blockquote",[s("p",[t._v("嵌套块元素垂直外边距的合并")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("对于两个嵌套关系的块元素，如果父元素没有上内边距及边框，\n则父元素的上外边距会与子元素的上外边距发生合并，\n合并后的外边距为两者中的较大者，\n即使父元素的上外边距为0，也会发生合并。\n")])])]),s("p",[s("img",{attrs:{src:"/assets/css-img/n.png",alt:"垂直元素合并"}})]),t._v(" "),s("p",[t._v("解决方案：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1. 可以为父元素定义1像素的上边框或上内边距。\n2. 可以为父元素添加overflow:hidden。\n")])])]),s("ol",[s("li",[s("p",[t._v("**实际应用注意：在实际工作中，我们很难直接话的得到盒子的内容的大小，所以我们会直接将整个盒子量出来，在后续如果需要添加padding的情况下 一定要减掉 padding **")])]),t._v(" "),s("li",[s("p",[t._v("如果这个块级盒子没有width属性（从父级继承宽度）的时候，添加padding和border不会撑大盒子（盒子内容部分会自动压缩）")])])])])}),[],!1,null,null,null);a.default=r.exports}}]);